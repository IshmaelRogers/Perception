## Ishmael Rogers 
## Robotics Software Engineer, Infinitely Deep Research Group
## www.idrg.io
## Udacity Perception Project
## 2018

pcl_callback() Function
---
This function will be called each time a message is publish to the "/pr2/world/points topic. It consist of the entire perception pipeline (i.e segmentation, clustering and object recognition). It also calls the pr2 mover function that tells the robot how to pick and place the object of interest. 

Cluster Segmentation
--- 


Given a dataset containing n number of points <a href="https://www.codecogs.com/eqnedit.php?latex=(p_{1},&space;p_{2},\cdots,&space;p_{n}&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?(p_{1},&space;p_{2},\cdots,&space;p_{n}&space;)" title="(p_{1}, p_{2},\cdots, p_{n} )" /></a> plotted based on two or more features, we would like to cluster the points together into k different clusters: 

 0. Randomly select k individual point as the initial cluster centroids: <a href="https://www.codecogs.com/eqnedit.php?latex=(c_{1},&space;c_{2},\cdots,&space;c_{k}&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?(c_{1},&space;c_{2},\cdots,&space;c_{k}&space;)" title="(c_{1}, c_{2},\cdots, c_{k} )" /></a>
 1. Define convergance/termination criteria based on solution stabillity and max number of iterations.
 2. While convergence/termination criteria are not met:
    for i = 1 to n:
        Calculate the distance from point <a href="https://www.codecogs.com/eqnedit.php?latex=p_{i}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{i}" title="p_{i}" /></a> to each cluster centroid.
        Assign <a href="https://www.codecogs.com/eqnedit.php?latex=p_{i}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p_{i}" title="p_{i}" /></a> to its closest centroid and label it accordingly
        NOTE: The partition created in this step represent a Voronoi diagram generated by the centroids 
        end for loop
 3. For j = 1 to k:
        Recompute the centroid of cluster j based on the average of all data points that belong to the cluster.
         NOTE: The centroids <a href="https://www.codecogs.com/eqnedit.php?latex=(c_{1},&space;c_{2},\cdots,&space;c_{k}&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?(c_{1},&space;c_{2},\cdots,&space;c_{k}&space;)" title="(c_{1}, c_{2},\cdots, c_{k} )" /></a> will shift to the new location 
    endfor
 endwhile 
 
The process of clustering will result in k number of different items grouped from the dataset clustered together based on the features specifed on the axis of the plot.

Steps for cluster segmentation have been added to the pcl_callback() function in the template Python script. Not required, but to help your reviewer consider adding screenshots of output at different steps in your writeup with brief explanations.
---

Both compute_color_histograms() and compute_normal_histograms() functions have been filled out and SVM has been trained using train_svm.py. Please provide a snapshot of your normalized confusion matrix (output from train_svm.py in your writeup / README. Object recognition steps have been implemented in the pcl_callback() function within template Python script. Not required, but to help your reviewer consider adding screenshots of output at different steps in your writeup with brief explanations.
---

# Pick and Place Setup

You can add this functionality to your already existing ros node or create a new node that communicates with your perception pipeline to perform sequential object recognition. Save your PickPlace requests into output_1.yaml, output_2.yaml, and output_3.yaml for each scene respectively. Add screenshots in your writeup of output showing label markers in RViz to demonstrate your object recognition success rate in each of the three scenarios. Note: for a passing submission, your pipeline must correctly identify 100% of objects in test1.world, 80% (4/5) in test2.world and 75% (6/8) in test3.world.
